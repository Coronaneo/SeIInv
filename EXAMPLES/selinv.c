/**********************************************************************
***********************************************************************

   Version:        0.1
   Last modified:  October 27, 2009
   Authors:        
     Chao Yang,
     Computer Research Division, Lawrence Berkeley National Lab
     Lin Lin,
     Program in Applied and Computational Mathematics, Princeton
     University

***********************************************************************
***********************************************************************

     selinv.c is the driver routine that computes the selected
     inversion of a sparse, symmetric, nonsingular linear system based
     on its sparse ldl' factorization. In particular, the diagonal
     elements are saved. 

     Usage: selinv.x -file=<filename> -order=<n> -chkerr=1\n");
     -file	:   Input file name. This file should should have the 
		    extension ".ccf" and this format can be generated by
		    convertmat.x under the directory UTILITIES/.
		    Matrix Market (MM) format is supported there.

     -order     :   Reordering strategy:
		    order = -1 (default) : Multiple Minimum Degree Reordering.
		    If METIS is supported, then the following choices
		    are also available:
		    order = 2 : Node Nested Dissection
		    order = 3 : Edge Nested Dissection

     -chkerr    :   Whether full inversion is to be computed for
		    efficiency comparison.  
		    chkerr = 0 (default). Only perform selected inversion.
		    chkerr = 1. Both selected inversion and full
    		      inversion are computed.


***********************************************************************
**********************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <time.h>

#define nzvals(i) nzvals[(i)-1]
#define rowind(i) rowind[(i)-1]
#define colptr(i) colptr[(i)-1]
#define xsol(i)   xsol[(i)-1]
#define rhs(i)    rhs[(i)-1]
#define diag(i)   diag[(i)-1]
#define diag2(i)  diag2[(i)-1]

extern int ldlt_preprocess__(int *, int *, int *, int *, int *, int *, int *);
extern int ldlt_fact__(int *, int *, int *, double *);
extern int ldlt_solve__(int *, double *, double *);
extern int ldlt_free__(int *);
extern int ldlt_selinv__(int *, double *, int*);

extern int readmatrixheader_(char *, int *, int *);
extern int readmatrix_(char *, int *, int *, double *);
#ifdef TIMING
extern double getime(void);
#endif

int main(int argc, char ** argv)
{
   int i, j, nnodes,nedges, ia, nnz, ibeg, iend ;
   int nx= -1, ny = -1, count, node;
   int *perm;
   int *rowind, *colptr;
   double *nzvals, *rhs, *xsol, *diag, *diag2;
   int token, order=-1;
   int Lnnz;
   double t0,t1, errmax; 
   long myclktck;
   double dval;
   double errabs;
   int chkerr = 0,  dumpL=0;
   int ierr = 0;
   char filename[120];
   
   ia = 1;
   if( argc == 1 ){
     fprintf(stderr, "invalide argument!\n");
     fprintf(stderr, "usage: selinv.x -file=<filename> -order=<-1|2|3> -chkerr=<0|1>\n");
     fprintf(stderr, "\n");
     fprintf(stderr, "For example, if the selected inversion of Harwell-Boeing matrix bcsstk14 is to be\n");
     fprintf(stderr, "computed, Multiple Minimum Degree reordering is used and full inversion is also \n");
     fprintf(stderr, "calculated for efficiency comparison, run\n");
     fprintf(stderr, "selinv.x -file=bcsstk14.ccf -order=-1 -chkerr=1\n");

     return 1;
   }

   while (ia < argc) {
      if ( !strncmp(argv[ia],"-file",5) ) {
	 strcpy(filename,&argv[ia][6]);
      }
      else if ( !strncmp(argv[ia],"-order",6) ) {
    	 order = atoi(&argv[ia][7]);
      }
      else if ( !strncmp(argv[ia],"-chkerr",7) ) {
    	 chkerr = atoi(&argv[ia][8]);
         if (chkerr != 0) chkerr = 1;
      }
      else {
 	 fprintf(stderr, "invalide argument!\n");
	 fprintf(stderr, "usage: selinvmain -file=<filename> -order=<-1|2|3> -chkerr=<0|1>\n");
         return 1;
      }
      ia++;
   }

   nnodes = 0;
   nnz = 0;
   

   readmatrixheader_(filename, &nnodes, &nnz);

   colptr = (int*)malloc((nnodes+1)*sizeof(int));
   rowind = (int*)malloc(nnz*sizeof(int));
   nzvals = (double*)malloc(nnz*sizeof(double));

   readmatrix_(filename, colptr, rowind, nzvals);

   token = 0;
  
   perm = NULL;   /* perm is not used here*/
   ldlt_preprocess__(&token, &nnodes, colptr, rowind, &Lnnz, &order, perm);   
   printf(" NUMBER OF ROWS IN A = %d\n", nnodes);
   printf(" NUMBER OF NONZERO ELEMENTS IN A = %d\n" , nnz);
   printf(" NUMBER OF NONZERO ELEMENTS IN L = %d\n\n", Lnnz); 

   ldlt_fact__(&token, colptr, rowind, nzvals);

   rhs = (double*)calloc(nnodes,sizeof(double));
   xsol = (double*)calloc(nnodes,sizeof(double));
   diag = (double*)malloc(nnodes*sizeof(double));

   if (chkerr) {
      /* obtain the diagonal of inverse using the "slow" way, i.e. the
       * full inversion is calculated */
#ifdef TIMING
      t0 = getime();
#endif
/*
      for (i=1; i<=nnodes; i++) {
         rhs(i) = 1.0;
         ldlt_solve__(&token, xsol, rhs);
         diag(i) = xsol(i);
	 // printf("diag(i) = %11.3e  xsol(i) = %11.3e\n", diag(i), xsol(i));
         rhs(i) = 0.0;
      } 
*/
      ldlt_diaginv__(&token, diag); 
#ifdef TIMING
      t1 = getime();
      printf(" TIME FOR FULL INVERSION = %11.3e\n", (t1-t0));
#endif
   }


   /* selected inversion */
   diag2 = (double*)calloc(nnodes,sizeof(double));
   ldlt_selinv__(&token, diag2, &dumpL);

   if (chkerr) {
      errmax = 0.0;
      for (i=1; i<=nnodes; i++) {
          errabs = fabs(diag(i)-diag2(i));
	  // printf("diag(i) = %11.3e  diag2(i) = %11.3e\n", diag(i), diag2(i));
          if ( errabs > errmax )
              errmax = errabs; 
      }
      printf(" ERROR OF THE DIAGONAL ELEMENTS BETWEEN FULL INVERSION AND SELECTED INVERSION = %11.3e\n", errmax);
   }

   ldlt_free__(&token); 

   if (order == 0) free(perm);
   free(colptr); 
   free(rowind); 
   free(nzvals); 
   free(rhs); 
   free(xsol); 
   free(diag); 
   free(diag2); 
}
